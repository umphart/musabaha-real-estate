import React, { useState } from 'react';
import { FiUpload, FiX, FiFileText } from 'react-icons/fi';
import * as XLSX from 'xlsx';
import { getAuthToken, showAlert } from './adminUtils';

const ImportModal = ({ onClose, onSuccess }) => {
  const [csvFile, setCsvFile] = useState(null);
  const [importLoading, setImportLoading] = useState(false);

  const API_BASE_URL = process.env.REACT_APP_API_URL || 'https://musabaha-homes.onrender.com/api';

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      setCsvFile(file);
    }
  };

  // Function to generate email from first letters of name
  const generateEmailFromName = (name) => {
    const baseEmail = process.env.REACT_APP_DEFAULT_EMAIL_DOMAIN || 'musabaha.com';
    
    // Split name into words and get first letter of each word
    const nameParts = name.trim().split(/\s+/);
    let initials = '';
    
    if (nameParts.length === 1) {
      // If only one name, use first 3 letters
      initials = nameParts[0].substring(0, 3).toLowerCase();
    } else {
      // Use first letter of each name part
      initials = nameParts.map(part => part.charAt(0)).join('').toLowerCase();
    }
    
    // Remove any non-alphabet characters and ensure we have at least 2 characters
    initials = initials.replace(/[^a-z]/g, '');
    if (initials.length < 2) {
      initials = (name.replace(/[^a-z]/gi, '')).substring(0, 3).toLowerCase();
    }
    
    const randomSuffix = Math.floor(1000 + Math.random() * 9000);
    return `${initials}${randomSuffix}@${baseEmail}`;
  };

  // Function to normalize column names (remove spaces and standardize)
  const normalizeColumnNames = (data) => {
    return data.map(row => {
      const normalizedRow = {};
      Object.keys(row).forEach(key => {
        // Remove leading/trailing spaces and convert to lowercase
        const normalizedKey = key.trim().toLowerCase();
        normalizedRow[normalizedKey] = row[key];
      });
      return normalizedRow;
    });
  };

  const handleImportCSV = async () => {
    if (!csvFile) {
      showAlert('error', 'Please select a CSV file to import.');
      return;
    }

    setImportLoading(true);
    
    try {
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { 
            type: 'array',
            cellDates: true,
            cellText: false
          });
          
          const worksheet = workbook.Sheets[workbook.SheetNames[0]];
          let jsonData = XLSX.utils.sheet_to_json(worksheet, { 
            raw: false,
            defval: ''
          });

          if (jsonData.length === 0) {
            showAlert('error', 'CSV file is empty.');
            setImportLoading(false);
            return;
          }

          // Normalize column names to handle spaces and case issues
          jsonData = normalizeColumnNames(jsonData);
          console.log('Normalized data:', jsonData);

          const token = getAuthToken();
          let successCount = 0;
          let errorCount = 0;
          const errors = [];
          const dateErrors = [];
          const autoGeneratedEmails = [];

          const parseDate = (dateValue) => {
            if (!dateValue) return new Date().toISOString().split('T')[0];
            
            if (typeof dateValue === 'number') {
              const excelEpoch = new Date(1899, 11, 30);
              const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
              return date.toISOString().split('T')[0];
            }
            
            const dateStr = dateValue.toString().trim();
            
            // Handle various date formats including "1/26/25"
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
              return dateStr;
            }
            
            // Handle formats like "1/26/25", "1/26/2025", etc.
            const separators = /[\/\-\.]/;
            const parts = dateStr.split(separators);
            
            if (parts.length === 3) {
              let month, day, year;
              
              // Handle MM/DD/YY or MM/DD/YYYY
              if (parts[0].length <= 2 && parts[1].length <= 2) {
                [month, day, year] = parts;
                
                // Handle 2-digit years
                if (year.length === 2) {
                  year = parseInt(year) < 50 ? `20${year}` : `19${year}`;
                }
                
                // Ensure 4-digit year
                year = year.padStart(4, '20');
                month = month.padStart(2, '0');
                day = day.padStart(2, '0');
                
                const date = new Date(`${year}-${month}-${day}`);
                if (!isNaN(date.getTime())) {
                  return date.toISOString().split('T')[0];
                }
              }
            }
            
            // Try parsing as is
            const parsedDate = new Date(dateStr);
            if (!isNaN(parsedDate.getTime())) {
              return parsedDate.toISOString().split('T')[0];
            }
            
            return new Date().toISOString().split('T')[0];
          };

          const isValidDate = (dateStr) => {
            const regex = /^\d{4}-\d{2}-\d{2}$/;
            if (!regex.test(dateStr)) return false;
            
            const date = new Date(dateStr);
            return !isNaN(date.getTime()) && dateStr === date.toISOString().split('T')[0];
          };

          // Validate email format
          const isValidEmail = (email) => {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email);
          };

          // Validate contact format
          const isValidContact = (contact) => {
            return contact && contact.length >= 10 && /^\d+$/.test(contact);
          };

          for (const [index, row] of jsonData.entries()) {
            try {
              console.log(`Processing row ${index + 2}:`, row);

              // Use normalized column names
              const name = row.name || row.name;
              const email = row.email || row.email;
              const contact = row.contact || row.contact;
              const plot_taken = row.plot_taken || row.plottaken || row.plot;
              const date_taken = row.date_taken || row.datetaken || row.date;
              const initial_deposit = row.initial_deposit || row.initialdeposit;
              const price_per_plot = row.price_per_plot || row.priceperplot;
              const payment_schedule = row.payment_schedule || row.paymentschedule;
              const total_balance = row.total_balance || row.totalbalance;
              const total_money_to_pay = row.total_money_to_pay || row.totalmoneytopay;
              const status = row.status;
              const plot_number = row.plot_number || row.plotnumber;

              // Validate required fields
              if (!name || !name.toString().trim()) {
                errors.push(`Row ${index + 2}: Missing name`);
                errorCount++;
                continue;
              }

              if (!contact || !contact.toString().trim()) {
                errors.push(`Row ${index + 2}: Missing contact`);
                errorCount++;
                continue;
              }

              if (!plot_taken || !plot_taken.toString().trim()) {
                errors.push(`Row ${index + 2}: Missing plot_taken`);
                errorCount++;
                continue;
              }

              // Process email - generate from name if not provided
              let finalEmail = '';
              let emailWasGenerated = false;
              
              if (email && email.toString().trim()) {
                finalEmail = email.toString().trim().toLowerCase();
                if (!isValidEmail(finalEmail)) {
                  errors.push(`Row ${index + 2}: Invalid email format - ${finalEmail}`);
                  errorCount++;
                  continue;
                }
              } else {
                // Generate email from first letters of name
                finalEmail = generateEmailFromName(name);
                emailWasGenerated = true;
                autoGeneratedEmails.push(`${name} -> ${finalEmail}`);
              }

              // Process contact
              let cleanContact = contact.toString().trim();
              // Remove any non-digit characters
              cleanContact = cleanContact.replace(/\D/g, '');
              
              // Ensure it starts with 0 and has 11 digits
              if (cleanContact.length === 10 && !cleanContact.startsWith('0')) {
                cleanContact = '0' + cleanContact;
              }
              
              if (!isValidContact(cleanContact)) {
                errors.push(`Row ${index + 2}: Invalid contact number - must be at least 10 digits, got ${cleanContact}`);
                errorCount++;
                continue;
              }

              // Process plot_taken
              let cleanPlotTaken = plot_taken.toString().trim();
              cleanPlotTaken = cleanPlotTaken.replace(/["']/g, ''); // Remove quotes

              // Process date
              let formattedDate = '';
              try {
                formattedDate = parseDate(date_taken);
                
                if (!isValidDate(formattedDate)) {
                  throw new Error(`Invalid date format: ${date_taken}`);
                }
              } catch (error) {
                dateErrors.push(`Row ${index + 2}: ${error.message}`);
                formattedDate = new Date().toISOString().split('T')[0];
              }

              // Calculate plot number
              const plotNumberValue = cleanPlotTaken.split(',').length;

              // Process price per plot
              let pricePerPlotValue = '3700000';
              if (price_per_plot) {
                pricePerPlotValue = price_per_plot.toString().trim();
                // Remove .00 if present
                pricePerPlotValue = pricePerPlotValue.replace(/\.00$/, '');
              }
              
              if (plotNumberValue > 1 && !pricePerPlotValue.includes(',')) {
                pricePerPlotValue = Array(plotNumberValue).fill(pricePerPlotValue).join(', ');
              }

              // Process payment schedule
              let paymentScheduleValue = 'Monthly';
              if (payment_schedule) {
                const schedule = payment_schedule.toString().trim();
                if (schedule.includes('Daily') || schedule === 'Every Day (Daily)') {
                  paymentScheduleValue = 'Daily';
                } else if (schedule.includes('Quarterly')) {
                  paymentScheduleValue = 'Quarterly';
                } else if (schedule.includes('3 Months')) {
                  paymentScheduleValue = '3 Months';
                } else if (schedule.includes('12 Months')) {
                  paymentScheduleValue = '12 Months';
                } else if (schedule.includes('18 Months')) {
                  paymentScheduleValue = '18 Months';
                } else if (schedule.includes('24 Months')) {
                  paymentScheduleValue = '24 Months';
                } else if (schedule.includes('30 Months')) {
                  paymentScheduleValue = '30 Months';
                } else {
                  paymentScheduleValue = 'Monthly';
                }
              }

              // Process numeric values
              let totalMoneyToPayValue = 0;
              if (total_money_to_pay) {
                totalMoneyToPayValue = parseFloat(total_money_to_pay) || 0;
              }
              
              if (!totalMoneyToPayValue && pricePerPlotValue) {
                const prices = pricePerPlotValue.split(',').map(p => parseFloat(p.trim()) || 0);
                totalMoneyToPayValue = prices.reduce((sum, price) => sum + price, 0);
              }

              let totalBalanceValue = 0;
              if (total_balance) {
                totalBalanceValue = parseFloat(total_balance) || 0;
              }
              
              if (!totalBalanceValue && totalMoneyToPayValue) {
                const initialDepositValue = parseFloat(initial_deposit) || 0;
                totalBalanceValue = Math.max(0, totalMoneyToPayValue - initialDepositValue);
              }

              const initialDepositValue = initial_deposit ? parseFloat(initial_deposit) : 0;

              // Prepare user data
              const userData = {
                name: name.toString().trim(),
                email: finalEmail,
                contact: cleanContact,
                plot_taken: cleanPlotTaken,
                date_taken: formattedDate,
                initial_deposit: initialDepositValue.toString(),
                price_per_plot: pricePerPlotValue,
                payment_schedule: paymentScheduleValue,
                total_balance: totalBalanceValue.toString(),
                total_money_to_pay: totalMoneyToPayValue.toString(),
                status: (status ? status.toString().toLowerCase() : 'active'),
                plot_number: plotNumberValue
              };

              console.log('Sending user data:', userData);
              if (emailWasGenerated) {
                console.log(`Auto-generated email for ${name}: ${finalEmail}`);
              }

              // Send API request
              const response = await fetch(`${API_BASE_URL}/admin/users`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(userData)
              });

              const result = await response.json();
              console.log('API Response:', result);
              
              if (result.success) {
                successCount++;
              } else {
                errorCount++;
                const errorMsg = `Row ${index + 2}: ${result.message || 'Failed to create user'}`;
                errors.push(errorMsg);
              }
            } catch (error) {
              errorCount++;
              const errorMsg = `Row ${index + 2}: ${error.message}`;
              errors.push(errorMsg);
              console.error('Error in row processing:', error);
            }
          }

          setCsvFile(null);
          
          // Show results with auto-generated email info
          let resultMessage = '';
          if (successCount > 0) {
            if (errorCount > 0) {
              resultMessage = `Imported ${successCount} users successfully. ${errorCount} failed.`;
            } else {
              resultMessage = `Successfully imported ${successCount} users!`;
            }
            
            if (autoGeneratedEmails.length > 0) {
              resultMessage += ` ${autoGeneratedEmails.length} emails were auto-generated.`;
              console.log('Auto-generated emails:', autoGeneratedEmails);
            }
            
            if (dateErrors.length > 0) {
              resultMessage += ` ${dateErrors.length} date conversion issues occurred.`;
            }
            
            showAlert(errorCount > 0 ? 'warning' : 'success', resultMessage);
            onSuccess();
          } else {
            showAlert('error', `No users were imported. ${errors.length > 0 ? errors[0] : 'Please check your CSV format.'}`);
          }

        } catch (error) {
          console.error('Error processing CSV:', error);
          showAlert('error', `Error processing CSV file: ${error.message}`);
        } finally {
          setImportLoading(false);
        }
      };
      
      reader.onerror = (error) => {
        console.error('File reading error:', error);
        showAlert('error', 'Error reading file. Please try again.');
        setImportLoading(false);
      };
      
      reader.readAsArrayBuffer(csvFile);
    } catch (error) {
      console.error('Error importing CSV:', error);
      showAlert('error', `Failed to import CSV file: ${error.message}`);
      setImportLoading(false);
    }
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h3><FiUpload className="icon" /> Import Users from CSV</h3>
          <button className="modal-close" onClick={onClose}>
            <FiX />
          </button>
        </div>
        <div className="modal-body">
          <div className="import-instructions">
            <h4>CSV Format Requirements:</h4>
            <ul>
              <li>File must be in CSV format</li>
              <li>Include these columns: <strong>name, email, contact, plot_taken, date_taken, initial_deposit, price_per_plot, payment_schedule, total_balance, total_money_to_pay, status, plot_number</strong></li>
              <li><strong>Note:</strong> Column names should not have leading spaces</li>
              <li><strong>Contact is required</strong></li>
              <li><strong>Email is optional</strong> - will be auto-generated from name initials if not provided</li>
              <li>Date format: YYYY-MM-DD (or MM/DD/YYYY)</li>
              <li>Contact format: 10-11 digits (e.g., 08098822844 or 8098822844)</li>
            </ul>
            <div className="email-generation-examples">
              <h5>Email Generation Examples:</h5>
              <ul>
                <li><strong>Umar Musa Halliru</strong> → umh1234@musabaha.com</li>
                <li><strong>Dalhat Faturu Dalhat</strong> → dfd5678@musabaha.com</li>
                <li><strong>Faisal Umar Farouk</strong> → fuf9012@musabaha.com</li>
                <li><strong>Aisha</strong> → aish3456@musabaha.com (single name uses first 3 letters)</li>
              </ul>
            </div>
          </div>

          <div className="file-upload-section">
            <label className="file-upload-label">
              <FiUpload className="icon" />
              Choose CSV File
              <input
                type="file"
                accept=".csv,.xlsx,.xls"
                onChange={handleFileUpload}
                className="file-input"
              />
            </label>
            {csvFile && (
              <div className="file-info">
                <FiFileText className="icon" />
                <span>{csvFile.name}</span>
                <span>({(csvFile.size / 1024).toFixed(2)} KB)</span>
              </div>
            )}
          </div>
        </div>
        <div className="modal-footer">
          <button 
            className="btn btn-secondary" 
            onClick={onClose}
            disabled={importLoading}
          >
            Cancel
          </button>
          <button 
            className="btn btn-primary" 
            onClick={handleImportCSV}
            disabled={!csvFile || importLoading}
          >
            {importLoading ? 'Importing...' : 'Import Users'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ImportModal;